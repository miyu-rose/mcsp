;========================================================================================
;
; mcsp version 1.00 by はう (Hau) ＆ みゆ (miyu rose)
;
;          mcsp Designer    みゆ (miyu rose)
;               Programmer  X68KBBS：X68K0001
;                           Twitter：@arith_rose
;
;          Special Adviser  はう (Hau) さま
;          mcsp Tester      X68KBBS：X68K0024
;                           Twitter：@Hau_oli
;
;========================================================================================

    .cpu    68000

    .include    doscall.mac
    .include    iocscall.mac

.ifndef _MACS
_MACS       .equ    $D0                         ; macsdrv.x
.endif

.ifndef _MALLOC3
_MALLOC3:   .equ    $ff90                       ; 060turbo.sys
.endif

;=========================================================================================

    .text
    .even

;=========================================================================================
; プログラム開始
;   a0   → メモリ管理ポインタのアドレス
;   a1   → 次のメモリ管理ポインタのアドレス（プログラム終端のアドレス+1）
;   a2   → 引数の文字列長（引数文字列ポインタ-1）
;-----------------------------------------------------------------------------------------
main:                                           ; 本プログラムの開始アドレス
    lea.l   mysp,sp                             ; スタック領域を自前で確保

;-----------------------------------------------------------------------------------------
; MACSデータの再生にローカルメモリ/ハイメモリを利用できない場合に備えて
; 本プログラムの直後のメモリ（メインメモリ）を利用可能な状態にしておく
;   a0   → メモリ管理ポインタのアドレス
;        ： プロセス管理ポインタの先頭アドレス
;   a1   → 次のメモリ管理ポインタのアドレス（プログラム終端のアドレス+1）
;        ： プロセス管理領域＋プログラムのサイズ
;-----------------------------------------------------------------------------------------

    lea     $10(a0),a0                          ; a0 にメモリブロックチェーン情報（$10 bytes）をスキップしてプロセス管理ポインタの先頭アドレスを取得
    sub.l   a0,a1                               ; a1 にプロセス管理領域＋プログラムのサイズを取得

    move.l  a1,-(sp)                            ; プロセス管理領域＋プログラムのサイズ
    move.l  a0,-(sp)                            ; プロセス管理ポインタの先頭アドレス
    DOS     _SETBLOCK                           ; プロセス管理ポインタの先頭アドレスから次のメモリ管理ポインタ直前までのメモリを確保
                                                ;  → 結果的に、本プログラムの直後のメモリが確保可能な状態となります
    addq.l  #8,sp                               ;
    tst.l   d0                                  ; _SETBLOCK のエラーコードが
    bpl     99f                                 ;  正常終了ならば次へ

    pea.l   err_Human68k                        ; Human68k の致命的なエラーが発生していますエラー（予期せぬ謎現象）
    bra     error                               ; エラー終了

99:

;-----------------------------------------------------------------------------------------
; タイトル表示
;   mlib_title     → タイトル文字列のアドレス
;   mlib_version   → バージョン文字列のアドレス
;   mlib_by        → by文字列のアドレス
;   mlib_author    → 作者文字列のアドレス
;-----------------------------------------------------------------------------------------

    bsr       disp_Title                        ; タイトル表示

;-----------------------------------------------------------------------------------------
; 引数処理
;   d0.l ： テンポラリ（主に引数文字フェッチ用）
;   a2   → 次のメモリ管理ポインタのアドレス（プログラム終端のアドレス+1）
;        ： 引数文字列ポインタ
;   a6   ： ファイルパスのフェッチ文字格納先ポインタ
;-----------------------------------------------------------------------------------------

    addq.l  #1,a2                               ; a2 に引数文字列の先頭アドレスを取得（引数の文字列長をスキップ）
    lea.l   buf_filepath,a6                     ; a6 にファイルパスの先頭アドレスを取得
    move.b  #$ff, buf_filepath_end              ; ファイルパス終端マーカーを設置

check_arg:
    move.b  (a2)+,d0                            ; 引数文字をフェッチ
    cmpi.b  #' ',d0                             ; ' ' と比較して
    beq     check_arg                           ;  同じならスキップ

    tst.b   d0                                  ; 終端文字と比較して
    beq     99f                                 ;  同じなら引数チェック終了

    cmpi.b  #'-',d0                             ; '-' と比較して
    beq     check_arg_option                    ;  同じならオプション引数チェックへ

    bra     arg_filepath                        ; ファイルパス処理へ

check_arg_option:
    move.b  (a2)+,d0                            ; 次のオプション引数文字をフェッチ
    tst.b   d0                                  ; 終端文字と比較して
    beq     99f                                 ;  同じなら引数チェック終了

    ori.b   #$20,d0                             ; アルファベット小文字化
    cmpi.b  #'i',d0                             ; 'i' と比較して
    beq     arg_option_i                        ;  同じなら i オプション処理へ

    cmpi.b  #' ',d0                             ; ' ' と比較して
    beq     check_arg                           ;  同じなら次の引数へ

    bra     check_arg_option                    ; 次のオプション引数文字へ（ループ）

arg_option_i:
    bset.b  #0,flg_option                       ; i フラグを立てる
    bra     check_arg_option                    ; 次のオプション引数文字へ（ループ）

arg_filepath:
    move.b  d0,(a6)+                            ; ファイルパスへ追記
    tst.b   (a6)                                ; 次のファイルパス格納先が
    beq     @f                                  ;  $00 ならまだ書き込めるので次へ

    clr.b   (a6)                                ; パス長の上限に到達したので終端文字 $00 を書き込んで
    bra     99f                                 ;   強制的に引数チェック終了
@@:
    move.b  (a2)+,d0                            ; 次の引数文字をフェッチ
    cmpi.b  #' ',d0                             ; ' ' と比較して
    beq     99f                                 ;  同じならファイルパス終端なので引数チェック終了
    tst.b   d0                                  ; 終端文字と比較して
    beq     99f                                 ;  同じならファイルパス終端なので引数チェック終了
    bra     arg_filepath                        ; ファイルパスへ追記（ループ）

99:

;-----------------------------------------------------------------------------------------
; MACSDATAファイルチェック
;   d0.l ： テンポラリ（主にDOSCALL返り値）
;   d6.l ： ファイルサイズ
;   d7.l ： ファイルハンドル
;   a1   ： MACSDATAのチェック用バッファアドレス
;-----------------------------------------------------------------------------------------

check_file:
    move.b  buf_filepath,d0                     ; d0 にファイルパス１文字目を取得
    tst.b   d0                                  ; その値が
    bne     @f                                  ;  $00 でなければファイルパスが指定されているので次へ

    pea.l   mes_help                            ; ファイルパスが指定されていないのでヘルプ
    bra     error                               ; エラー終了
@@:
    clr.w   -(sp)                               ; READモードで
    pea.l   buf_filepath                        ;  指定されたファイルを
    DOS     _OPEN                               ;  開く
    addq.l  #6,sp
    move.l  d0,d7                               ; ファイルハンドルを d7 に保存
    bpl     @f                                  ; 負の値でなければ正常なので次へ

    pea.l   err_fileopen                        ; ファイルが開けませんエラー
    bra     error                               ; エラー処理
@@:

check_filesize:
    move.w  #2,-(sp)                            ; モード ファイル終端から
    clr.l   -(sp)                               ; オフセット 0
    move.w  d7,-(sp)                            ; ファイルハンドル
    DOS     _SEEK                               ; シークします（d0 にファイル先頭からのオフセット = ファイルサイズが返ります）
    addq.l  #8,sp                               ; SP を戻します
    move.l  d0,d6                               ; ファイルサイズを d6 へ保存
    bpl     @f                                  ; 負の値でなければ正常なので次へ

    pea.l   err_fileseek                        ; ファイルが壊れていますエラー
    bra     error                               ; エラー処理
@@:
    cmp.l   #18,d6                              ; 最小のMACSファイルサイズ 18Bytes と比較して
    bpl     @f                                  ; 大きければ問題なし

    pea.l   err_notmacs                         ; MACSファイルじゃないよエラー
    bra     error                               ; エラー処理
@@:
    clr.w   -(sp)                               ; モード ファイル先頭から
    clr.l   -(sp)                               ; オフセット 0
    move.w  d7,-(sp)                            ; ファイルハンドル
    DOS     _SEEK                               ; シークします
    addq.l  #8,sp                               ; SP を戻します
    tst.l   d0                                  ; d0 の値が
    bpl     @f                                  ;  負の値でなければ正常なので次へ

    pea.l   err_fileseek                        ; ファイルが壊れていますエラー
    bra     error                               ; エラー処理
@@:

check_macsdata:
    lea.l   buf_macsmagic,a1                    ; MACSデータのマジックワード 'MACSDATA' チェック用バッファ

    move.l  #$10,-(sp)                          ; 読み込むサイズ $10 Bytes
    pea.l   (a1)                                ; 読み込みバッファ
    move.w  d7,-(sp)                            ; ファイルハンドル
    DOS     _READ                               ; 読み込みます
    lea.l   10(sp),sp                           ; SP を戻します
    tst.l   d0                                  ; 読み込んだサイズが
    bpl     @f                                  ;  負の値でなければ正常なので次へ

    pea.l   err_fileread                        ; ファイルを読み込みできませんでしたエラー
    bra     error                               ; エラー処理
@@:

check_magicword:
    cmp.l   #'MACS',(a1)                        ; 'MACS' と比較して
    beq     @f                                  ;  同じなら次へ

    pea.l   err_notmacs                         ; MACSファイルじゃないよエラー表示
    bra     error                               ; エラー処理
@@:
    cmp.l   #'DATA',4(a1)                       ; 'DATA' と比較して
    beq     @f                                  ;  同じなら次へ

    pea.l   err_notmacs                         ; MACSファイルじゃないよエラー表示
    bra     error                               ; エラー処理
@@:

;-----------------------------------------------------------------------------------------
; MACSDATA情報表示
;   d0.l ： テンポラリ（DOSCALL返り値）
;   d1.l ： テンポラリ
;   d4.w ： MACSDATAバージョン
;   d7.l ： ファイルハンドル
;   a1   ： MACSDATAのチェック用バッファアドレス
;-----------------------------------------------------------------------------------------

print_dataversion:
    pea.l   mes_dataversion                     ; 'DataVersion:'
    DOS     _PRINT                              ;  を表示するよ
    addq.l  #4,sp                               ; SP を戻します

    move.w #$0002,-(sp)                         ; 黄色の
    move.w #$0002,-(sp)                         ;  文字属性
    DOS    _CONCTRL                             ;   に設定するよ
    addq.l #4,sp                                ; SP を戻します

    move.w 8(a1),d4                             ; d4 に MACSDATAバージョンを取得
    move.b 8(a1),d0                             ; d0 に MACSDATAメインバージョンを取得
    lsr.b  #4,d0                                ; d0 に MACSDATAメインバージョンの１桁目を取得
    beq    @f                                   ; メインバージョン１桁目が 0 だったらスキップ

    bsr    mlib_puthex                          ; メインバージョン１桁目を表示するよ
@@:
    move.b 8(a1),d0                             ; d0 に MACSDATAメインバージョンを取得
    and.b  #$0f,d0                              ; d0 に MACSDATAメインバージョンの２桁目を取得
    bsr    mlib_puthex                          ; メインバージョン２桁目を表示するよ

    move.w #'.',-(sp)                           ; '.' を
    DOS    _PUTCHAR                             ;  表示するよ
    addq.l #2,sp                                ; SP を戻します

    move.b d4,d0                                ; d0 に MACSDATAマイナーバージョンを取得
    lsr.b  #4,d0                                ; d0 に MACSDATAマイナーバージョンの１桁目を取得
    bsr    mlib_puthex                          ; マイナーバージョン１桁目を表示するよ

    move.b d4,d0                                ; d0 に MACSDATAマイナーバージョンを取得
    and.b  #$0f,d0                              ; d0 に MACSDATAマイナーバージョンの２桁目を取得
    bsr    mlib_puthex                          ; マイナーバージョン２桁目を表示するよ
    move.w #$0003,-(sp)                         ; 白色の
    move.w #$0002,-(sp)                         ;  文字属性
    DOS    _CONCTRL                             ;   に設定するよ
    addq.l #4,sp                                ; SP を戻します

    pea.l  mes_filesize                         ; 'FileSize:'を
    DOS    _PRINT                               ;  表示するよ
    addq.l #4,sp                                ; SP を戻します

    move.w #$0002,-(sp)                         ; 黄色の
    move.w #$0002,-(sp)                         ;  文字属性
    DOS    _CONCTRL                             ;   に設定するよ
    addq.l #4,sp                                ; SP を戻します

    move.l 10(a1),d0                            ; ファイルサイズを取得
    cmp.l  #$400,d0                             ; 1024(1KB) と比較して
    bge    @f                                   ; 大きければ次へ

    bsr    mlib_printdec                        ; 十進数表示するよ

    pea.l  mes_unit_B                           ; '[B]' を
    DOS    _PRINT                               ;  表示するよ
    addq.l #4,sp                                ; SP を戻します

    bra    9f                                   ; 次へ
@@:
    lsr.l  #8,d0                                ; d0.l を 8bit右シフト
    lsr.l  #2,d0                                ; d0.l を 2bit右シフト(1024で割るために計10bit右シフト)
    cmp.l  #$400,d0                             ; 1024(1MB) と比較して
    bge    @f                                   ; 大きければ次へ

    bsr    mlib_printdec                        ; 十進数表示するよ

    pea.l  mes_unit_KB                          ; '[KB]' を
    DOS    _PRINT                               ;  表示するよ
    addq.l #4,sp                                ; SP を戻します

    bra    9f                                   ; 次へ
@@:
    lsr.l  #8,d0                                ; d0.l を 8bit右シフト
    lsr.l  #2,d0                                ; d0.l を 2bit右シフト(1024で割るために計10bit右シフト)

    bsr    mlib_printdec                        ; 十進数表示するよ

    pea.l  mes_unit_MB                          ; '[MB]' を
    DOS    _PRINT                               ;  表示するよ
    addq.l #4,sp                                ; SP を戻します
9:
    move.w #$0003,-(sp)                         ; 白色の（←標準設定に戻す）
    move.w #$0002,-(sp)                         ;  文字属性
    DOS    _CONCTRL                             ;   に設定するよ
    pea.l  mlib_crlf                            ; 改行を
    DOS    _PRINT                               ;  表示するよ
    addq.l #8,sp                                ; SP を戻します

    bra    @f                                   ; 次へ

read_command:
    move.l  #$2,-(sp)                           ; 読み込むサイズ $2 Bytes
    pea.l   buf_command                         ; 読み込みバッファ
    move.w  d7,-(sp)                            ; ファイルハンドル
    DOS     _READ                               ; 読み込みます
    lea.l   10(sp),sp                           ; SP を戻します
    tst.l   d0                                  ; 読み込んだサイズが
    bpl     @f                                  ;  負の値でなければ正常なので次へ

    pea.l   err_fileread                        ; ファイルを読み込みできませんでしたエラー
    bra     error                               ; エラー処理
@@:

check_command:
    move.w buf_command,d0                       ; d0 に読み込んだMACSコマンドを取得

    cmp.w  #$0001,d0                            ; $0001（初期化）と比較して
    beq    read_command                         ;  同じならスキップして次のコマンドへ

    cmp.w  #$002C,d0                            ; $002C（コメント）と比較して
    beq    read_commentsize                     ;  同じならコメント表示へ

    bra    99f                                  ; それ以外ならデータ部なので表示終わり

read_commentsize:
    move.l  #$2,-(sp)                           ; 読み込むサイズ $2 Bytes
    pea.l   buf_command                         ; 読み込みバッファ
    move.w  d7,-(sp)                            ; ファイルハンドル
    DOS     _READ                               ; 読み込みます
    lea.l   10(sp),sp                           ; SP を戻します
    tst.l   d0                                  ; 読み込んだサイズが
    bpl     @f                                  ;  負の値でなければ正常なので次へ

    pea.l   err_fileread                        ; ファイルを読み込みできませんでしたエラー
    bra     error                               ; エラー処理
@@:
    clr.l   d1                                  ; d1 を初期化
    move.w  buf_command,d1                      ; d1 にコメントサイズを取得
    move.l  d1,d0                               ; d0 にコメントサイズを取得
    cmp.w   #$00ff,d0                           ; $ff(255) Bytes と比較して
    ble     @f                                  ;  以下なら次へ

    move.w  #$00ff,d0                           ; 強制的に $ff(255) Bytes で打ち切る
@@:

read_comment:
    move.l  d0,-(sp)                            ; 読み込むサイズ
    pea.l   buf_comment                         ; 読み込みバッファ
    move.w  d7,-(sp)                            ; ファイルハンドル
    DOS     _READ                               ; 読み込みます
    lea.l   10(sp),sp                           ; SP を戻します
    tst.l   d0                                  ; 読み込んだサイズが
    bpl     @f                                  ;  負の値でなければ正常なので次へ

    pea.l   err_fileread                        ; ファイルを読み込みできませんでしたエラー
    bra     error                               ; エラー処理
@@:
    sub.l   d0,d1                               ; d1 -= d0
    beq     @f                                  ; 差分なし（コメントサイズが 255 Bytes 以内）ならスキップ

    move.w  #1,-(sp)                            ; モード ファイル現在位置から
    move.l  d1,-(sp)                            ; オフセット
    move.w  d7,-(sp)                            ; ファイルハンドル
    DOS     _SEEK                               ; シークします
    addq.l  #8,sp                               ; SP を戻します
    move.l  d0,d6                               ; ファイルサイズを d6 へ保存
    bpl     @f                                  ; 負の値でなければ正常なので次へ

    pea.l   err_fileseek                        ; ファイルが壊れていますエラー
    bra     error                               ; エラー処理
@@:

print_comment:
    pea.l   buf_comment                         ; コメントを
    DOS     _PRINT                              ;  表示するよ
    pea.l   mlib_crlf                           ; 改行を
    DOS     _PRINT                              ;  表示するよ
    addq.l  #8,sp                               ; SP を戻します

    bra     read_command                        ; 次のMACSコマンドを取得

99:
    pea.l  mlib_crlf                            ; 改行を
    DOS    _PRINT                               ;  表示するよ
    addq.l #4,sp                                ; SP を戻します

    btst.b #0,flg_option                        ; i オプションが
    bne    EXIT                                 ; 立っていたらここでおしまい

;-----------------------------------------------------------------------------------------
; MACSDRV の常駐チェック
;   d0.l ： テンポラリ
;   d4.w → MACSDATAバージョン
;   d5.w ： MACSDRV バージョン
;   a1   ： IOCS $D0 (_MACS) のベクタアドレス+2（macsdrv が常駐されていたら'MACSIOCS'が格納されているはず）
;-----------------------------------------------------------------------------------------

check_MACSDRV:
    lea.l   $01d0*4.w,a1                        ; a1 に IOCS $D0 (_MACS) のベクタアドレスが格納されているベクタテーブルのアドレスを取得
    IOCS    _B_LPEEK                            ; d0.l に a1 番地の値（_MACS のベクタアドレス）を取得（スーパーバイザ領域）
    movea.l d0,a1                               ; a1 に _MACS のベクタアドレスを取得

    addq.l  #2,a1                               ; ベクタアドレスから 2 Bytes 後に設定（MACSDRV なら 'MACSIOCS' があるはず）して
    IOCS    _B_LPEEK                            ;  その値を d0.l に取得（スーパーバイザ領域）
    cmp.l   #'MACS',d0                          ; 'MACS' と比較して
    beq     @f                                  ;  同じなら次へ

    pea.l   err_MACSDRV                         ; MACSDRV が常駐していませんエラー
    bra     error                               ; エラー終了
@@:
    IOCS    _B_LPEEK                            ; d0.0 に次の値を取得（スーパーバイザ領域）
    cmp.l   #'IOCS',d0                          ; 'IOCS' と比較して
    beq     @f                                  ;  同じなら MACSDRV は組み込まれているので次へ

    pea.l   err_MACSDRV                         ; MACSDRV が常駐していませんエラー
    bra     error                               ; エラー終了
@@:

check_MACSDRV_version:
    moveq.l #3,d1                               ; MACSバージョンチェック
    IOCS    _MACS                               ; 常駐している MACSDRV のバージョンを取得
    move.w  d0,d5                               ; d5 に MACSDRVバージョンを取得

    cmp.w   d4,d5                               ; MACSDATAバージョンと比較
    bge     @f                                  ; MACSDRVバージョンがMACSデータバージョン以上なので次へ

    pea.l   err_version                         ; MACSDRV のバージョンが古いですエラー
    bra     error                               ; エラー処理
@@:
    cmp.w   #$0116,d0                           ; バージョン0.116 と比較して
    ble     check_mainmem                       ; 小さければハイメモリ非対応なのでメインメモリのチェックへ

;-----------------------------------------------------------------------------------------
; ローカルメモリのチェック
;   d0.l ： テンポラリ（主に _MALLOC3 の返り値）
;   d3.l ： 確保可能なメモリサイズ
;   a1   ： 確保したメモリの先頭アドレス
;-----------------------------------------------------------------------------------------

check_localmem:
    pea     $FFFF_FFFF                          ; 確保するメモリサイズ（わざとエラーにして確保可能な最大メモリサイズを取得する）
    DOS      _MALLOC3                           ; 060turbo.sys 拡張MALLOC（_MALLOC3 が存在するなら確保可能な最大メモリサイズ(理論値256MB)に最上位bitを立てた値が、存在しなければ -1 が d0 に返る）
    addq.l  #4,sp                               ; SP を戻します
    move.l  d0,d3                               ; d3.l に返り値を保存
    addq.l  #1,d0                               ; d0.l をインクリメント（_MALLOC3 が存在しない場合は -1 なので 0 になる）
    beq     check_HIMEMSYS                      ; _MALLOC3 が存在しないので HIMEM.SYS チェック

    bclr.l  #31,d3                              ; d3.l の最上位bitを下げて確保可能な最大メモリサイズ(理論値256MB)を取得
    cmp.l   #$00C0_0000,d3                      ; 確保可能なメモリサイズを 12MB と比較して
    blt     check_HIMEMSYS                      ;  小さかったら HIMEM.SYS チェック（12MB未満のローカルメモリを確保可能という可能性も微レ存ですが確保不可とみなします）

allocate_localmem:                              ; 060turbo.sys + ローカルメモリ(ハイメモリ)確定
    move.l  d3,-(sp)                            ; 確保するメモリサイズ
    DOS     _MALLOC3                            ; ローカルメモリを確保（確保できたら先頭アドレスが、できなかったら -1 が d0 に返る）
    move.l  d0,(sp)+                            ; SP を戻しつつ d0 の判定
    bpl     @f                                  ; 確保できたので次へ

    pea.l   err_localmem                        ; ローカルメモリを確保できませんでしたエラー（予期せぬ謎現象）
    bra     error                               ; エラー処理
@@:
    move.l  d0,a1                               ; a1 に先頭アドレスを取得
    bset.b  #1,flg_memory                       ; ローカルメモリ確保フラグ
    bra     load_macs                           ; MACS ファイルのロード

;-----------------------------------------------------------------------------------------
; ハイメモリ(HIMEM.SYS)のチェック（060turbo.sys / TS16drv / TS16drvp からも組み込み可）
;   d0.l ： テンポラリ
;   d1.l ： テンポラリ
;   d2.l ： 確保しようとするメモリサイズ（テンポラリ）
;   d3.l ： 確保可能なメモリサイズ
;   a1   ： 確保したメモリの先頭アドレス
;-----------------------------------------------------------------------------------------

check_HIMEMSYS:
    lea.l   $01f8*4.w,a1                        ; a1 に IOCS $F8 (_HIMEM) のベクタアドレスが格納されているベクタテーブルのアドレスを取得
    IOCS    _B_LPEEK                            ; d0.l に a1 番地の値（_HIMEM のベクタアドレス）を取得（スーパーバイザ領域）
    movea.l d0,a1                               ; a1 に _HIMEM のベクタアドレスを取得

    subq.l  #6,a1                               ; ベクタアドレスから 6 Bytes 前に設定（HIMEM.SYS なら 'HIMEM' + 1 byte があるはず）して
    IOCS    _B_LPEEK                            ;  その値を d0.l に取得（スーパーバイザ領域）
    cmp.l   #'HIME',d0                          ; 'HIME' と比較して
    bne     check_mainmem                       ; 違っていたら HIMEM.SYS は組み込まれていないのでメインメモリのチェックへ
    IOCS    _B_BPEEK                            ; d0.b に次の値を取得
    cmp.b   #'M',d0                             ; 'M' と比較して
    bne     check_mainmem                       ; 違っていたら HIMEM.SYS は組み込まれていないのでメインメモリのチェックへ

allocate_highmem:
    moveq.l #3,d1                               ; メモリ残量を
    IOCS    _HIMEM                              ;  d1.l に取得
    move.l  d1,d3                               ; d3.l にメモリ残量＝確保可能な最大メモリサイズを取得

    move.l  d1,d2                               ; 確保しようとするメモリサイズ d2.l
    moveq.l #1,d1                               ; メモリブロックを
    IOCS    _HIMEM                              ;   確保（確保できたら先頭アドレスが a1 に、できなかったら d0 に -1 が返る）
    tst.l   d0                                  ; d0 の判定
    bpl     @f                                  ; 確保できたので次へ

    pea.l   err_highmem                         ; ハイメモリを確保できませんでしたエラー（予期せぬ謎現象）
    bra     error                               ; エラー処理
@@:
    bset.b  #2,flg_memory                       ; ハイメモリ確保フラグ
    bra     load_macs                           ; MACS ファイルのロード

;-----------------------------------------------------------------------------------------
; メインメモリのチェック
;   d0.l ： テンポラリ（主に _MALLOC の返り値）
;   d3.l ： 確保可能なメモリサイズ
;   a1   ： 確保したメモリの先頭アドレス
;-----------------------------------------------------------------------------------------

check_mainmem:
    pea     $FFFF_FFFF                          ; 確保するメモリサイズ（わざとエラーにして確保可能なメモリサイズ最大値を取得する）
    DOS     _MALLOC                             ; メモリ確保（確保可能な最大メモリサイズ(理論値12MB)に最上位byteのフラグを立てた値が d0 に返る）
    addq.l  #4,sp                               ; SP を戻します
    andi.l  #$00FF_FFFF,d0                      ; d0.l に確保可能な最大メモリサイズ(理論値12MB)を取得
    move.l  d0,d3                               ; d3.l に確保可能な最大メモリサイズ(理論値12MB)を取得

allocate_mainmem:
    move.l  d3,-(sp)                            ; 確保しようとするメモリサイズ
    DOS     _MALLOC                             ; メインメモリ確保（確保できたら d0 に 先頭アドレスが返り、できなかったら d0 に負の値が返る）
    move.l  d0,(sp)+                            ; SP を戻しつつ d0 の判定
    bpl     @f                                  ; 負の値ではないので次へ

    pea.l   err_mainmem                         ; メモリを確保できませんでしたエラー（予期せぬ謎現象）
    bra     error                               ; エラー処理
@@:
    movea.l d0,a1                               ; a1 に先頭アドレスを取得
    bset.b  #0,flg_memory                       ; メインメモリ確保フラグ

;-----------------------------------------------------------------------------------------
; MACS ファイルのロード
;   d0.l ： テンポラリ
;   d3.l → 確保可能なメモリサイズ
;   d4.w → MACSDATAバージョン
;   d6.l → ファイルサイズ
;   d7.w → ファイルハンドル
;   a1   → 確保したメモリの先頭アドレス
;-----------------------------------------------------------------------------------------

load_macs:
    cmp.l   d3,d6                               ; 確保可能なメモリサイズとファイルサイズを比較して
    blt     @f                                  ;  ロード可能であれば次へ

    pea.l   err_sizeover                        ; メモリを確保できませんでしたエラー
    bra     error                               ; エラー処理
@@:
    clr.w   -(sp)                               ; モード ファイル先頭から
    clr.l   -(sp)                               ; オフセット 0
    move.w  d7,-(sp)                            ; ファイルハンドル
    DOS     _SEEK                               ; シークします
    addq.l  #8,sp                               ; SP を戻します
    tst.l   d0                                  ; d0 の値が
    bpl     @f                                  ;  負の値でなければ正常なので次へ

    pea.l   err_fileseek                        ; ファイルが壊れていますエラー
    bra     error                               ; エラー処理
@@:
    move.l  d6,-(sp)                            ; ファイルサイズ
    pea.l   (a1)                                ; 確保したメモリの先頭アドレス
    move.w  d7,-(sp)                            ; ファイルハンドル
    DOS     _READ                               ; MACSデータをメモリに積む
    lea     10(sp),sp                           ; SP を戻します

;-----------------------------------------------------------------------------------------
; MACS データの再生
;   d1.l ： テンポラリ（_MACSの引数）
;   d2.l ： テンポラリ（_MACSの引数）
;   d4.l ： テンポラリ（_MACSの引数）
;-----------------------------------------------------------------------------------------

    clr.l   d1                                  ;  0 : アニメーション再生
    move.l  #-1,d2                              ; -1 : 自動停止制御はしません
    clr.l   d4                                  ;  0 : 特殊効果フラグは全オフ
    IOCS    _MACS                               ; MACS再生

    bra     release_mem                         ; メモリ解放

;-----------------------------------------------------------------------------------------
; エラー処理
;-----------------------------------------------------------------------------------------

error:
    DOS     _PRINT                              ; 表示するよ
    pea.l   mlib_crlf2                          ; 改行を
    DOS     _PRINT                              ;  表示するよ
    addq.l  #8,sp                               ; SP を戻します

;-----------------------------------------------------------------------------------------
; 確保したメモリの解放
;   d1.l ： テンポラリ
;   d2.l ： テンポラリ
;   a1   :  確保したメモリの先頭アドレス
;-----------------------------------------------------------------------------------------

release_mem:
    tst.b   flg_memory                          ; メモリ確保フラグが
    beq     EXIT                                ;  立っていなければおしまい
    btst.b  #2,flg_memory                       ; メモリ確保フラグを #2（ハイメモリ）と比較
    bne     @f                                  ;  同じならハイメモリの解放へ

    move.l  a1,-(sp)                            ; 確保したメモリの先頭アドレス
    DOS     _MFREE                              ; メインメモリ/ローカルメモリの解放
    addq.l  #4,sp                               ; SP を戻します

    bra     EXIT                                ; おしまい
@@:
    move.l  a1,d2                               ; 確保したメモリの先頭アドレス
    moveq.l #2,d1                               ; メモリブロックの解放
    IOCS    _HIMEM                              ; ハイメモリの解放

;-----------------------------------------------------------------------------------------
; おしまい
;-----------------------------------------------------------------------------------------

EXIT:
    DOS     _EXIT                               ; おしまい

;=========================================================================================

;-----------------------------------------------------------------------------------------
; タイトル表示
;-----------------------------------------------------------------------------------------

disp_Title:
    bsr     mlib_printtitle                     ; Title 表示
    rts

;=========================================================================================

    .data
    .even

;-----------------------------------------------------------------------------------------

mlib_title::
    .dc.b   'mcsp.x ',$00
mlib_version::
    .dc.b   $F3,'v',$F3,'e',$F3,'r',$F3,'s',$F3,'i',$F3,'o',$F3,'n',$F3,' '
    .dc.b   $F3,'1',$F3,'.',$F3,'0',$F3,'0',$F3,' ',$00
mlib_by::
    .dc.b   ' ',$F3,'b',$F3,'y ',$00
mlib_author::
    .dc.b   'みゆ (miyu rose)',$00

mes_help:
    .dc.b   ' mcsp [options] [MACSfile]',$0D,$0A
    .dc.b   '  [options]',$0D,$0A
    .dc.b   '   -d : macsdata information only (not play)',$0D,$0A
    .dc.b   $00

mes_dataversion:
    .dc.b   $F3,'D',$F3,'a',$F3,'t',$F3,'a',$F3,'V',$F3,'e',$F3,'r',$F3,'s',$F3,'i',$F3,'o',$F3,'n',$F3,':',$00

mes_filesize:
    .dc.b   ' ',$F3,'F',$F3,'i',$F3,'l',$F3,'e',$F3,'S',$F3,'i',$F3,'z',$F3,'e',$F3,':',$00

mes_unit_B:
    .dc.b   '[B]',$00

mes_unit_KB:
    .dc.b   '[KB]',$00

mes_unit_MB:
    .dc.b   '[MB]',$00

err_Human68k:
    .dc.b   'Human68kの致命的なエラーにつき再起動をオススメします',$00

err_notmacs:
    .dc.b   'MACSファイルじゃないみたいです',$00

err_MACSDRV:
    .dc.b   'MACSDRV が常駐していないようです',$00

err_version:
    .dc.b   'MACSDRV のバージョンが古いようです',$00

err_localmem:
    .dc.b   'ローカルメモリを確保できませんでした',$00

err_highmem:
    .dc.b   'ハイメモリを確保できませんでした',$00

err_mainmem:
    .dc.b   'メインメモリを確保できませんでした',$00

err_sizeover:
    .dc.b   '十分な空きメモリがありませんでした',$00

err_fileopen:
    .dc.b   'ご指定のファイルを開けませんでした',$00

err_fileseek:
    .dc.b   'ファイルが壊れている可能性があります',$00

err_fileread:
    .dc.b   'ファイルを読み込みできませんでした',$00

;-----------------------------------------------------------------------------------------

    .bss
    .even

;-----------------------------------------------------------------------------------------

flg_option:                                     ; bit76543210
    .ds.b    1                                  ;   %00000001 i オプション(情報表示のみ再生ナシ)

flg_memory:                                     ; bit76543210
    .ds.b    1                                  ;   %00000001 メインメモリ確保
                                                ;   %00000010 ローカルメモリ確保(060turbo.sys)
                                                ;   %00000100 ハイメモリ確保(HIMEM.SYS/TS16DRVx)
buf_filepath:
    .ds.b    2
    .ds.b   64
    .ds.b   18
    .ds.b    4
buf_filepath_end:
    .ds.b    1

;-----------------------------------------------------------------------------------------

    .bss
    .even

;-----------------------------------------------------------------------------------------

buf_macsmagic:
    .ds.b    8
buf_dataversion:
    .ds.b    2
buf_macssize:
    .ds.l    1
buf_command:
    .ds.w    1
buf_comment:
    .ds.b   255
buf_comment_end
    .ds.b   1

;-----------------------------------------------------------------------------------------

    .stack
    .even

;-----------------------------------------------------------------------------------------

mystack:
    .ds.l   1024
mysp:
    .end    main

;=========================================================================================
